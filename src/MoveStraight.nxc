#define WAIT_TIME 10

struct motorStruct {
int speed;              // 0%-100% Speed
int turn;               // -100% - 100% Turn
bool direction;         // 1: Fwd 0: Rev
};

struct sensorBoolStruct {
bool middle;
bool right;
bool left;
};

struct sensorIntStruct {
int middle;
int right;
int left;
};

motorStruct MoveStraight(sensorBoolStruct inputSensors){

    enum state {straight = 1, comp_right = 2, comp_left = 3, cross = 4, error = 99  };
    int Compensation = 10;
    int AmountCrosses_count = 0;
    int Speed; int AmountCrosses;
    int x;
    motorStruct returnMovement;

    if (inputSensors.middle
       && !inputSensors.right
       && !inputSensors.left)     //On track
       x = 1;
    else if (inputSensors.middle
       && !inputSensors.right
       && inputSensors.left)     //Out of track to the right
       x = 2;
    else if (inputSensors.middle
       && inputSensors.right
       && !inputSensors.left)     //Out of track to the left
       x = 3;
    else if (inputSensors.middle
       && inputSensors.right
       && inputSensors.left)     //Reached a cross
       x = 4;
    else                         //Error
       x = 99;



    switch(x)
    {
        case 1: //Go straight
             returnMovement.speed = Speed;
             returnMovement.turn = 0;
             returnMovement.direction = 1;
             break;

        case 2: //Right compensate
             returnMovement.speed = Speed;
             returnMovement.turn = Compensation;
             returnMovement.direction = 1;
             break;

        case 3: //Left compensate
             returnMovement.speed = Speed;
             returnMovement.turn = -Compensation;
             returnMovement.direction = 1;
             break;

        case 4: //Count up the crosses crossed
             AmountCrosses_count += AmountCrosses_count;
             break;
             
        case 99: //Error -> don't move
             returnMovement.speed = 0;
             returnMovement.turn = 0;
             returnMovement.direction = 1;


        default: // Shoud this be here?
        break;
    }
    
    return returnMovement;

}



task main(){
    // Configure inputs 2 and 3 to be light sensors.
    SetSensorLight(IN_1);
    SetSensorLight(IN_2);
    SetSensorLight(IN_3);

    sensorIntStruct sensor_raw;             // Variables where the raw value of the sensors will be stored.
    sensorBoolStruct sensor_bool;           // Boolean variables indicating if the sensors are detecting a black area.
    sensorIntStruct sensor_thresholds;      // Values defining the thresholds of the 3 sensors limits

    motorStruct motor;                      // Motors variables.

    // Main loop.
    while(true)
    {
        // Get the value of the 3 infrared sensors.
        sensor_raw.middle = Sensor(IN_1);
        sensor_raw.right = Sensor(IN_2);
        sensor_raw.left = Sensor(IN_3);

        // Print sensors values to screen.
        TextOut(10, LCD_LINE1, StrCat("mid sens.: ", NumToStr(sensor_raw.middle)));
        TextOut(10, LCD_LINE2, StrCat("r sens.: ", NumToStr(sensor_raw.right)));
        TextOut(10, LCD_LINE3, StrCat("l sens.: ", NumToStr(sensor_raw.left)));
        Wait(WAIT_TIME);
        // Go through every programmed behaviour.
        // 1st behaviour: move straight, following a black line.
        motor.speed = 50;
        motor.turn = 0;
        
        

        

        motor = MoveStraight(sensor_bool);
        

        // Set the output of the actuators.
        if (motor.direction == true)
            OnFwdSync(OUT_AC, motor.speed, motor.turn);
        else
            OnRevSync(OUT_AC, motor.speed, motor.turn);
    }
}
